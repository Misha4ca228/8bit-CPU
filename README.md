**Эмулятор 8-битного процессора** — программная модель, воспроизводящая архитектуру и поведение простого 8-битного ЦП. Реализует базовые инструкции (арифметические, логические, переходы, работа с памятью и регистрами), циклы тактирования и систему прерываний. Позволяет запускать и отлаживать машинный код, исследовать внутренние процессы работы процессора и использовать его как учебный инструмент для изучения архитектуры вычислительных систем.

- [Установка проекта](#установка-проекта)
- [Эмулятор](#эмулятор)
    - [Технические характеристики](#технические-характеристики)
	- [Терминал](#терминал)
	    - [Таблица символов](#таблица-символов)
	    - [Инструкции процессора](#инструкции-процессора)
	    - [Таблица инструкций](#таблица-инструкций)
- [Компилятор](#компилятор)
	- [Синтаксис компилятора](#синтаксис-компилятора)
	- [Формат инструкции](#формат-инструкции)
	- [Метки](#метки)
	- [Директивы данных](#директивы-данных)
	- [Комментарии](#комментарии)
	- [Правила синтаксиса](#правила-синтаксиса)

# Установка проекта

Клонируйте репозиторий в рабочую папку
```
git clone https://github.com/Misha4ca228/8bit-CPU.git
```

Перейдите в папку с проектом 

```
cd 8bit-CPU
```

Запустите исполняемый файл эмулятора


```
python main.py
```



# Эмулятор
## Технические характеристики
Память: Эмулятор имеет 256 Байт памяти, 16 последних байт предназначены для вывода символов на экран.

| Диапазон (HEX) | Диапазон (DEC) | Назначение                     |
| -------------- | -------------- | ------------------------------ |
| 0x00 – 0xEF    | 0 – 239        | Основная память                |
| 0xF0 – 0xFF    | 240 – 255      | Буфер вывода символов на экран |
Также эмулятор имеет 8 регистров, каждый регистр имеет память 1 байт, и PC (Program Counter) для указателя текущей инструкции

## Терминал

![Терминал](./assets/terminal.png)



Для вывода символов на экран терминала требуется загрузить код символа в соответствующую ячейку память от 0xF0 – 0xFF(240 – 255).
### Таблица символов
| DEC |    BIN     | Символ |
| :-: | :--------: | :----: |
|  0  | 0b00000000 |   ␣    |
|  1  | 0b00000001 |   :    |
|  2  | 0b00000010 |   !    |
|  3  | 0b00000011 |   ?    |
|  4  | 0b00000100 |   *    |
|  5  | 0b00000101 |   -    |
|  6  | 0b00000110 |   +    |
|  7  | 0b00000111 |   /    |
|  8  | 0b00001000 |   ,    |
|  9  | 0b00001001 |   .    |
| 10  | 0b00001010 |   A    |
| 11  | 0b00001011 |   B    |
| 12  | 0b00001100 |   C    |
| 13  | 0b00001101 |   D    |
| 14  | 0b00001110 |   E    |
| 15  | 0b00001111 |   F    |
| 16  | 0b00010000 |   G    |
| 17  | 0b00010001 |   H    |
| 18  | 0b00010010 |   I    |
| 19  | 0b00010011 |   J    |
| 20  | 0b00010100 |   K    |
| 21  | 0b00010101 |   L    |
| 22  | 0b00010110 |   M    |
| 23  | 0b00010111 |   N    |
| 24  | 0b00011000 |   O    |
| 25  | 0b00011001 |   P    |
| 26  | 0b00011010 |   Q    |
| 27  | 0b00011011 |   R    |
| 28  | 0b00011100 |   S    |
| 29  | 0b00011101 |   T    |
| 30  | 0b00011110 |   U    |
| 31  | 0b00011111 |   V    |
| 32  | 0b00100000 |   W    |
| 33  | 0b00100001 |   X    |
| 34  | 0b00100010 |   Y    |
| 35  | 0b00100011 |   Z    |
| 36  | 0b00100100 |   Б    |
| 37  | 0b00100101 |   Г    |
| 38  | 0b00100110 |   Д    |
| 39  | 0b00100111 |   Ж    |
| 40  | 0b00101000 |   З    |
| 41  | 0b00101001 |   И    |
| 42  | 0b00101010 |   Л    |
| 43  | 0b00101011 |   П    |
| 44  | 0b00101100 |   Ф    |
| 45  | 0b00101101 |   Ц    |
| 46  | 0b00101110 |   Ч    |
| 47  | 0b00101111 |   Ш    |
| 48  | 0b00110000 |   Щ    |
| 49  | 0b00110001 |   Ъ    |
| 50  | 0b00110010 |   Ы    |
| 51  | 0b00110011 |   Ь    |
| 52  | 0b00110100 |   Э    |
| 53  | 0b00110101 |   Ю    |
| 54  | 0b00110110 |   Я    |
| 55  | 0b00110111 |   0    |
| 56  | 0b00111000 |   1    |
| 57  | 0b00111001 |   2    |
| 58  | 0b00111010 |   3    |
| 59  | 0b00111011 |   4    |
| 60  | 0b00111100 |   5    |
| 61  | 0b00111101 |   6    |
| 62  | 0b00111110 |   7    |
| 63  | 0b00111111 |   8    |
| 64  | 0b01000000 |   9    |
| 65  | 0b01000001 |   =    |
| 66  | 0b01000010 |   (    |
| 67  | 0b01000011 |   )    |
| 68  | 0b01000100 |   _    |
| 69  | 0b01000101 |   &    |
| 70  | 0b01000110 |   @    |
| 71  | 0b01000111 |   %    |
| 72  | 0b01001000 |   $    |
| 73  | 0b01001001 |   ~    |
| 74  | 0b01001010 |   \|   |
| 75  | 0b01001011 |   <    |
| 76  | 0b01001100 |   >    |
| 77  | 0b01001101 |   ;    |
| 78  | 0b01001110 |   ✡    |
| 79  | 0b01001111 |   ^    |
| 80  | 0b01010000 |   #    |
| 81  | 0b01010001 |   [    |
| 82  | 0b01010010 |   ]    |
| 83  | 0b01010011 |   {    |
| 84  | 0b01010100 |   }    |
## Инструкции процессора

Процессора поддерживает 27 команд. Каждая инструкция представлена одним байтом (опкодом) и может иметь один или два операнда — регистры, адреса памяти или непосредственные значения.

Инструкции делятся на несколько категорий:

- **Работа с памятью и регистрами** — загрузка и сохранение данных.
- **Арифметические операции** — сложение, вычитание, умножение, деление.
- **Логические операции** — побитовые вычисления (AND, OR, XOR, NOT).
- **Переходы и условия** — изменение потока исполнения программы.
- **Служебные команды** — остановка процессора.

Все значения и адреса являются 8-битными (диапазон `0–255`).


## Таблица инструкций

| DEC |    BIN     | Команда  |   Аргументы   | Описание                                          |
| :-: | :--------: | :------: | :-----------: | :------------------------------------------------ |
|  1  | 0b00000001 | **LDI**  |    r, val     | Загрузить в регистр `r` значение `val`            |
|  2  | 0b00000010 |  **LD**  |    r, addr    | Загрузить в регистр `r` значение из памяти `addr` |
|  3  | 0b00000011 |  **ST**  |    r, addr    | Сохранить значение регистра `r` в память `addr`   |
|  4  | 0b00000100 | **MOV**  |    rA, rB     | Копировать значение `rB` в `rA`                   |
|  5  | 0b00000101 | **STI**  | r_src, r_addr | Сохранить `r_src` в адрес `MEM[Rr_addr]`          |
|  8  | 0b00001000 | **ADD**  |    rA, rB     | Сложить `rA = rA + rB`                            |
|  9  | 0b00001001 | **ADDI** |    r, val     | Прибавить к `r` константу `val`                   |
| 10  | 0b00001010 | **SUB**  |    rA, rB     | Вычесть `rA = rA - rB`                            |
| 11  | 0b00001011 | **SUBI** |    r, val     | Вычесть из `r` константу `val`                    |
| 12  | 0b00001100 | **MUL**  |    rA, rB     | Умножить `rA = rA * rB`                           |
| 13  | 0b00001101 | **DIV**  |    rA, rB     | Целочисленное деление `rA = rA / rB`              |
| 14  | 0b00001110 | **MOD**  |    rA, rB     | Остаток `rA = rA % rB`                            |
| 15  | 0b00001111 | **INC**  |       r       | Увеличить значение регистра на 1                  |
| 16  | 0b00010000 | **DEC**  |       r       | Уменьшить значение регистра на 1                  |
| 17  | 0b00010001 | **AND**  |    rA, rB     | Побитовое И (`rA = rA AND rB`)                    |
| 18  | 0b00010010 |  **OR**  |    rA, rB     | Побитовое ИЛИ (`rA = rA OR rB`)                   |
| 19  | 0b00010011 | **XOR**  |    rA, rB     | Побитовое XOR (`rA = rA XOR rB`)                  |
| 20  | 0b00010100 | **NOT**  |       r       | Побитовое отрицание (`r = NOT r`)                 |
| 24  | 0b00011000 | **JMP**  |     addr      | Безусловный переход на адрес `addr`               |
| 25  | 0b00011001 |  **JZ**  |    r, addr    | Переход на addr, если `r == 0`                    |
| 26  | 0b00011010 | **JNZ**  |    r, addr    | Переход на addr, если `r != 0`                    |
| 255 | 0b11111111 | **HALT** |       —       | Остановка программы                               |



# Компилятор 

Компилятор преобразует ассемблерный код пользовательской программы из файла `program.txt` в машинный байт-код, который может быть исполнен 8-битным эмулятором.  
Он поддерживает метки, комментарии и простые директивы данных (`$`).

Компилятор выполняет два прохода:

**Первый проход** — определяет все метки и вычисляет адреса команд.

**Второй проход** — формирует итоговый массив байт, заменяя инструкции и метки на их числовые коды.


Результатом работы является список байт (до 256), готовый для загрузки в память эмулятора.




# Синтаксис компилятора

Компилятор преобразует ассемблерный код (файл `program.txt`) в 8-битный машинный код, понятный эмулятору.  
Поддерживаются **инструкции, метки, комментарии и директивы данных**.

---

## Формат инструкции

Каждая строка программы содержит **одну инструкцию** и должна заканчиваться точкой с запятой `;`.

```
ИНСТРУКЦИЯ операнд1, операнд2;
```

Примеры:

```
LDI 0, 15;        # загрузить число 15 в регистр R0 
ST 0, 240;        # сохранить R0 в ячейку памяти 0xF0 
ADD 1, 0;         # сложить R1 = R1 + R0
HALT;             # остановить выполнение
```

---

## Метки

Метки задаются в начале строки и используются для переходов (`JMP`, `JZ`, `JNZ`):

```
loop_start:     
	INC 0;     
	JNZ 0, loop_start;     
	HALT;
```

---

## Директивы данных

Для записи констант напрямую в память используется символ `$`.  
Можно записывать несколько байт на одной строке.

`$10, $0xF0, $0b11001010;`

- Поддерживаются **десятичные**, **шестнадцатеричные (`0x`)** и **двоичные (`0b`)** форматы.
    
- Значения должны быть в диапазоне `0–255`.
    

---

## Комментарии

Комментарии начинаются символом `#` и игнорируются при компиляции.

```
LDI 0, 65;  # загрузить символ 'A' 
ST 0, 240;  # вывести на экран
```

---

## Правила синтаксиса

- Каждая команда заканчивается `;`.
    
- Имена меток должны быть **идентификаторами** (`A–Z`, `a–z`, цифры, `_`, без пробелов).
    
- Недопустимо переопределять метки.
    
- Максимальная длина программы — **256 байт**.
    
- Ошибки компиляции выводятся с номером строки и типом ошибки.
    

